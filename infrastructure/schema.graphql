scalar AWSTimestamp

type User {
  userId: ID!
  email: String!
  name: String!
  role: UserRole!
  profileImage: String
  tier: UserTier!
  phone: String
  bio: String
  genres: [String!]
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
  stats: UserStats!
  preferences: UserPreferences!
}

type UserStats {
  totalRequests: Int!
  successfulRequests: Int!
  eventsAttended: Int!
  genresExplored: [String!]!
}

type UserPreferences {
  notificationsEnabled: Boolean!
  hapticFeedback: Boolean!
  reducedMotion: Boolean!
}

enum UserRole {
  PERFORMER
  AUDIENCE
}

enum UserTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

type Event {
  eventId: ID!
  venueName: String
  venueLocation: VenueLocation
  startTime: AWSTimestamp
  endTime: AWSTimestamp
  status: EventStatus!
  theme: String
  createdBy: ID
  createdAt: AWSTimestamp!
  totalRevenue: Float!
  totalRequests: Int!
  djSets: [DJSet!]!
}

type DJSet {
  setId: ID!
  eventId: ID!
  performerId: ID!
  performer: User
  setStartTime: AWSTimestamp!
  setEndTime: AWSTimestamp!
  status: SetStatus!
  settings: EventSettings!
  isAcceptingRequests: Boolean!
  qrCode: String
  revenue: Float!
  requestCount: Int!
  createdAt: AWSTimestamp!
  
  playlistType: String
  playlistId: String
  playlistName: String
  playlistTracks: [String!]
  playlistAppliedAt: AWSTimestamp
}

type VenueLocation {
  address: String!
  city: String!
  province: String!
  coordinates: Coordinates
}

type Coordinates {
  lat: Float!
  lng: Float!
}

type EventSettings {
  basePrice: Float!
  requestCapPerHour: Int!
  spotlightSlotsPerBlock: Int!
  allowDedications: Boolean!
  allowGroupRequests: Boolean!
}

enum EventStatus {
  SCHEDULED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum SetStatus {
  SCHEDULED
  ACTIVE
  COMPLETED
  CANCELLED
}

type Request {
  requestId: ID!
  eventId: ID!
  setId: ID!
  performerId: ID!
  userId: ID!
  user: User
  userName: String
  userTier: UserTier
  songTitle: String!
  artistName: String!
  genre: String
  albumArt: String
  duration: String
  status: RequestStatus!
  requestType: RequestType!
  price: Float!
  queuePosition: Int
  dedication: String
  shoutout: String
  submittedAt: AWSTimestamp!
  acceptedAt: AWSTimestamp
  playedAt: AWSTimestamp
  vetoedAt: AWSTimestamp
  vetoReason: String
  vetoedBy: ID
  transactionId: String!
  refundTransactionId: String
  groupRequestId: String
  upvotes: Int!
}

enum RequestStatus {
  PENDING
  ACCEPTED
  APPROVED
  PLAYING
  COMPLETED
  VETOED
  VETOED_REFUND_PENDING
}

enum RequestType {
  STANDARD
  SPOTLIGHT
  GROUP
}

type Queue {
  setId: ID!
  eventId: ID!
  performerId: ID!
  orderedRequests: [Request!]!
  lastUpdated: AWSTimestamp!
  currentlyPlaying: Request
}

type Transaction {
  transactionId: ID!
  userId: ID!
  eventId: ID!
  requestId: ID!
  amount: Float!
  type: TransactionType!
  status: TransactionStatus!
  paymentProvider: PaymentProvider!
  providerTransactionId: String!
  createdAt: AWSTimestamp!
  completedAt: AWSTimestamp
}

enum TransactionType {
  CHARGE
  REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

enum PaymentProvider {
  YOCO
  PAYFAST
  OZOW
}

type Achievement {
  userId: ID!
  badges: [Badge!]!
  score: Int!
  milestones: Milestones!
}

type Badge {
  badgeId: ID!
  name: String!
  tier: UserTier!
  unlockedAt: AWSTimestamp!
}

type Milestones {
  firstRequest: AWSTimestamp
  firstGroupRequest: AWSTimestamp
  first10Requests: AWSTimestamp
  first50Requests: AWSTimestamp
}

type GroupRequest {
  groupRequestId: ID!
  eventId: ID!
  initiatorUserId: ID!
  initiator: User
  songTitle: String!
  artistName: String!
  targetAmount: Float!
  currentAmount: Float!
  contributors: [Contributor!]!
  status: GroupRequestStatus!
  expiresAt: AWSTimestamp!
  createdAt: AWSTimestamp!
  requestId: String
}

type Contributor {
  userId: ID!
  user: User
  amount: Float!
  contributedAt: AWSTimestamp!
}

enum GroupRequestStatus {
  FUNDING
  FUNDED
  EXPIRED
  COMPLETED
}

# ============================================
# ADMIN CRM ENUMS
# ============================================

enum UserStatus {
  ACTIVE
  SUSPENDED
  PENDING_VERIFICATION
  FLAGGED
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum EscrowStatus {
  PENDING
  HELD
  RELEASED
  REFUNDED
  DISPUTED
}

enum DisputeRaiser {
  FAN
  DJ
}

enum DisputeReason {
  SONG_NOT_PLAYED
  WRONG_SONG
  POOR_QUALITY
  EXCESSIVE_WAIT
  PAYMENT_ISSUE
  OTHER
}

enum DisputeStatus {
  OPEN
  INVESTIGATING
  ESCALATED
  RESOLVED
}

enum DisputePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

# ============================================
# ADMIN CRM TYPES
# ============================================

type AdminStats {
  totalDJs: Int!
  activeDJs: Int!
  totalFans: Int!
  activeFans: Int!
  totalTransactions: Int!
  heldFunds: Float!
  releasedToday: Float!
  pendingPayouts: Float!
  openDisputes: Int!
  platformRevenue: Float!
  platformRevenueToday: Float!
}

type AdminUser {
  userId: ID!
  email: String!
  name: String!
  role: UserRole!
  tier: UserTier!
  status: UserStatus!
  totalSpent: Float
  totalEarnings: Float
  totalRequests: Int!
  totalEvents: Int
  rating: Float
  createdAt: AWSTimestamp!
  lastActiveAt: AWSTimestamp
  verificationStatus: VerificationStatus
}

type AdminUserConnection {
  items: [AdminUser!]!
  nextToken: String
}

type AdminTransaction {
  transactionId: ID!
  requestId: ID!
  userId: ID!
  userName: String!
  performerId: ID!
  performerName: String!
  eventId: ID!
  eventName: String
  songTitle: String!
  artistName: String!
  amount: Float!
  platformFee: Float!
  performerEarnings: Float!
  status: EscrowStatus!
  paymentProvider: PaymentProvider!
  providerTransactionId: String!
  createdAt: AWSTimestamp!
  releasedAt: AWSTimestamp
  refundedAt: AWSTimestamp
}

type AdminTransactionConnection {
  items: [AdminTransaction!]!
  nextToken: String
}

type Dispute {
  disputeId: ID!
  transactionId: ID!
  raisedBy: DisputeRaiser!
  raisedById: ID!
  raisedByName: String!
  reason: DisputeReason!
  description: String!
  status: DisputeStatus!
  priority: DisputePriority!
  assignedTo: String
  resolution: String
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
  resolvedAt: AWSTimestamp
}

type DisputeConnection {
  items: [Dispute!]!
  nextToken: String
}

type Payout {
  payoutId: ID!
  performerId: ID!
  performerName: String!
  amount: Float!
  transactionCount: Int!
  status: PayoutStatus!
  bankName: String!
  accountNumber: String!
  reference: String!
  createdAt: AWSTimestamp!
  processedAt: AWSTimestamp
  failureReason: String
}

type PayoutConnection {
  items: [Payout!]!
  nextToken: String
}

type EventConnection {
  items: [Event!]!
  nextToken: String
}

type Track {
  trackId: ID!
  eventId: ID!
  performerId: ID!
  title: String!
  artist: String!
  genre: String
  albumArt: String
  duration: Int
  basePrice: Float!
  isEnabled: Boolean!
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
}

type Query {
  getUser(userId: ID!): User
  getEvent(eventId: ID!): Event
  listActiveEvents(limit: Int, nextToken: String): EventConnection
  getDJSet(setId: ID!): DJSet
  listEventDJSets(eventId: ID!): [DJSet!]!
  listPerformerSets(performerId: ID!, limit: Int): [DJSet!]!
  getQueue(setId: ID!): Queue
  getEventTracklist(eventId: ID!): [Track!]!
  getRequest(requestId: ID!): Request
  getUserRequests(userId: ID!, limit: Int): [Request!]!
  getUserActiveRequests(userId: ID!, eventId: ID!): [Request!]!
  getEventRequests(eventId: ID!, status: RequestStatus): [Request!]!
  getSetRequests(setId: ID!, status: RequestStatus): [Request!]!
  getTransaction(transactionId: ID!): Transaction
  getUserTransactions(userId: ID!, limit: Int): [Transaction!]!
  getAchievements(userId: ID!): Achievement
  getGroupRequest(groupRequestId: ID!): GroupRequest
  listActiveGroupRequests(eventId: ID!): [GroupRequest!]!
  
  # Admin CRM Queries (require Admins group)
  getAdminStats: AdminStats @aws_auth(cognito_groups: ["Admins"])
  listAllUsers(role: String, limit: Int, nextToken: String): AdminUserConnection @aws_auth(cognito_groups: ["Admins"])
  listAllTransactions(status: String, limit: Int, nextToken: String): AdminTransactionConnection @aws_auth(cognito_groups: ["Admins"])
  listAllDisputes(status: String, limit: Int, nextToken: String): DisputeConnection @aws_auth(cognito_groups: ["Admins"])
  listAllPayouts(status: String, limit: Int, nextToken: String): PayoutConnection @aws_auth(cognito_groups: ["Admins"])
}

input VenueLocationInput {
  address: String
  city: String
  province: String
}

input CreateEventInput {
  venueName: String!
  venueLocation: VenueLocationInput
  startTime: AWSTimestamp!
  endTime: AWSTimestamp!
  status: EventStatus
  theme: String
}

input CreateDJSetInput {
  eventId: ID!
  setStartTime: AWSTimestamp!
  setEndTime: AWSTimestamp!
  basePrice: Float
  requestCapPerHour: Int
  spotlightSlotsPerBlock: Int
  allowDedications: Boolean
  allowGroupRequests: Boolean
}

input CreateRequestInput {
  eventId: ID!
  setId: ID!
  songTitle: String!
  artistName: String!
  genre: String
  requestType: RequestType!
  dedication: String
  shoutout: String
}

input GroupRequestInput {
  eventId: ID!
  songTitle: String!
  artistName: String!
  targetAmount: Float!
}

input UpdateDJSetSettingsInput {
  requestCapPerHour: Int
  basePrice: Float
  isSoldOut: Boolean
  allowDedications: Boolean
  allowGroupRequests: Boolean
  spotlightSlotsPerBlock: Int
}

input UpdateSetPlaylistInput {
  setId: ID!
  playlistType: String!
  playlistId: String!
  playlistName: String!
  playlistTracks: [String!]!
}

input UpdateDJProfileInput {
  name: String
  bio: String
  genres: [String!]
  photo: String
  basePrice: Float
}

input SubmitRequestWithPaymentInput {
  eventId: ID!
  setId: ID
  songTitle: String!
  artistName: String!
  genre: String
  requestType: RequestType!
  dedication: String
  shoutout: String
  yocoChargeId: String!
  idempotencyKey: String!
}

type SubmitRequestWithPaymentResponse {
  success: Boolean!
  request: Request
  transaction: Transaction
  errorCode: String
  errorMessage: String
}

type RefundResponse {
  refundId: ID!
  amount: Float!
  status: String!
  transactionId: ID!
  estimatedDays: String
  refundedAt: AWSTimestamp
}

input SongInput {
  title: String!
  artist: String!
  genre: String
  basePrice: Float
  isEnabled: Boolean
  albumArt: String
  duration: Int
}

type UploadTracklistResponse {
  success: Boolean!
  songsAdded: Int!
  songs: [Track!]
}

type SetEventTracklistResponse {
  success: Boolean!
  eventId: ID!
  songsCount: Int!
}

type Mutation {
  createUser(email: String!, name: String!, role: UserRole!): User
  updateUser(userId: ID!, name: String, profileImage: String, phone: String): User
  updateDJProfile(userId: ID!, input: UpdateDJProfileInput!): User
  
  createEvent(input: CreateEventInput!): Event
  updateEventStatus(eventId: ID!, status: EventStatus!): Event
  
  createDJSet(input: CreateDJSetInput!): DJSet
  updateDJSetStatus(setId: ID!, status: SetStatus!): DJSet
  updateSetStatus(setId: ID!, status: String!): DJSet
  updateDJSetSettings(setId: ID!, input: UpdateDJSetSettingsInput!): DJSet
  updateSetPlaylist(input: UpdateSetPlaylistInput!): DJSet
  toggleSetAvailability(setId: ID!, isAcceptingRequests: Boolean!): DJSet
  
  createRequest(input: CreateRequestInput!): Request
  acceptRequest(requestId: ID!, setId: ID!): Request
  updateRequestStatus(requestId: ID!, status: RequestStatus!): Request
  markRequestAsPlaying(requestId: ID!, setId: ID!): Request
  markRequestAsCompleted(requestId: ID!): Request
  vetoRequest(requestId: ID!, reason: String): Request
  
  reorderQueue(setId: ID!, orderedRequestIds: [ID!]!): Queue
  upvoteRequest(requestId: ID!): Request
  
  createGroupRequest(input: GroupRequestInput!): GroupRequest
  contributeToGroupRequest(groupRequestId: ID!, amount: Float!): GroupRequest
  
  submitRequestWithPayment(input: SubmitRequestWithPaymentInput!): SubmitRequestWithPaymentResponse!
  processRefund(requestId: ID!, reason: String): RefundResponse
  
  # Tracklist Management
  uploadTracklist(performerId: ID!, songs: [SongInput!]!): UploadTracklistResponse!
  setEventTracklist(eventId: ID!, songIds: [ID!]!): SetEventTracklistResponse!
  
  # Admin CRM Mutations (require Admins group)
  updateUserStatus(userId: ID!, status: String!, reason: String): AdminUser @aws_auth(cognito_groups: ["Admins"])
  releaseEscrowFunds(transactionId: ID!): AdminTransaction @aws_auth(cognito_groups: ["Admins"])
  refundTransaction(transactionId: ID!, reason: String!): AdminTransaction @aws_auth(cognito_groups: ["Admins"])
  resolveDispute(disputeId: ID!, resolution: String!, action: String!): Dispute @aws_auth(cognito_groups: ["Admins"])
  processAdminPayout(payoutId: ID!): Payout @aws_auth(cognito_groups: ["Admins"])
}

type Subscription {
  onQueueUpdate(eventId: ID!): Queue
    @aws_subscribe(mutations: ["reorderQueue"])
  
  onRequestStatusChange(requestId: ID!): Request
    @aws_subscribe(mutations: ["updateRequestStatus", "vetoRequest"])
  
  onNewRequest(eventId: ID!): Request
    @aws_subscribe(mutations: ["createRequest"])
  
  onEventUpdate(eventId: ID!): Event
    @aws_subscribe(mutations: ["updateEventStatus"])
  
  onGroupRequestUpdate(groupRequestId: ID!): GroupRequest
    @aws_subscribe(mutations: ["contributeToGroupRequest"])
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
